

//same thing for sort and reverse

//index diya hai toh row ke hisab se and woh bhi sirf first row
//isme sara row ko reverse krne ke liye use for loop
for(int i=0;i<matrix.si'ze();i++)
  reverse(matrix[i].begin(),matrix[i].end());



//agr kuch index ni hai toh first col ke hisab se kaam ho rha
//isse sara col reverse hogya
  reverse(matrix.begin(),matrix.end());


// Appends 10 occurrences of '$'
    // to str
    str.append(10, '$');

int a = b is setting a's VALUE to b's VALUE
int* a = &b is setting a's VALUE to the ADDRESS of b
int& a = b is setting a's ADDRESS to b's ADDRESS (a is a reference to b)


int maximum69Number (int num) {
        string s_num = to_string(num);//int to string
        for (auto &c : s_num) {
            if (c == '6') {
                c = '9';
                break;
            }
        }
        return stoi(s_num);//string to int



//IN BS FIND THE LOW AND HIGH RANGE BY TAKING BEST AND WROST CASES, AND
//THEN OPERATE IN THE RANGE

  //AGRESSIVE COWS
  #include <bits/stdc++.h>
    using namespace std;
    bool isPossible(int a[], int n, int cows, int minDist) {
        int cntCows = 1; 
        int lastPlacedCow = a[0];
        for(int i = 1;i<n;i++) {
            if(a[i] - lastPlacedCow >= minDist) {
                cntCows++;
                lastPlacedCow = a[i]; 
            }
        }
        if(cntCows >= cows) return true;
        return false; 
    }\
    int main() {
    	int t;
    	cin >> t;
    	while(t--) {
    	    int n, cows;
    	    cin >> n >> cows;
    	    int a[n];
    	    for(int i = 0;i<n;i++) cin >> a[i]; 
    	    sort(a,a+n); 
    	    
    	    int low = 1, high = a[n-1] - a[0]; 
    	    
    	    while(low <= high) {
    	        int mid = (low + high) >> 1; 
    	        
    	        if(isPossible(a,n,cows,mid)) {
    	            low = mid + 1;
    	        }
    	        else {
    	            high = mid - 1; 
    	        }
    	    }
    	    cout << high << endl; 
    	}
    	return 0;
    } 

//find k closest elements to x in a given  sorted array
 vector<int> findClosestElements(vector<int>& arr, int k, int x) {
        vector<int>ans;
        int n=arr.size();
        //range dekh ke lena hai
        int l=0;
        int r=n-k;
    //we are finding the stating point closest to x
        while(l<r){
            int mid= l+(r-l)/2;
            //yaha pr gap check kro jitna bada gap utna dur hoga x se
            if(x-arr[mid]>arr[mid+k]-x)
                l=mid+1;
            else
                r=mid;
        }
        //here l and r will same 
        
        //ab yaha se k elements daal do
       for(int i=r;i<r+k;i++){
           ans.push_back(arr[i]);
       }
        return ans;
    }

//Allocate Minimum Number of Pages,SAME AS PAINTER-PARTITION PROBLEM
int isPossible(vector<int> &A, int pages, int students) {
    int cnt = 0;
    int sumAllocated = 0; 
    for(int i = 0;i<A.size();i++) {
        if(sumAllocated + A[i] > pages) {
            cnt++; 
            sumAllocated = A[i];
            if(sumAllocated > pages) return false; 
        }
        else {
            sumAllocated += A[i];
        }
    }
    if(cnt < students) return true; 
    return false; 
}
int Solution::books(vector<int> &A, int B) {
    if(B > A.size()) return -1; 
    int low = A[0]; 
    int high = 0;
    for(int i = 0;i<A.size();i++) {
        high = high + A[i]; 
        low = min(low, A[i]); 
    }
    int res = -1; 
    while(low <= high) {
        int mid = (low + high) >> 1; 
        //cout << low << " " << high << " " << mid << endl; 
        if(isPossible(A, mid, B)) {
            res = mid; 
            high = mid - 1; 
        }
        else {
            low = mid + 1; 
        }
    }
    // return res -> this is also correct
    return low; 
}
//WOOD-CUTTING MADE EASY.
public class Solution {
    public static int solve(int[] A, int B) {
       
      int h = 0;
      int max = 0;
      int min =0;
      int ans = 0;
      
      for(int i=0;i<A.length;i++){
          max = Math.max(max,A[i]);
      }
      
     while(min<=max){
          int mid = min+(max-min)/2;
          long wood = 0;
          for(int j=0;j<A.length;j++){
              if(A[j]-mid>0){
                  wood = wood+A[j]-mid;
              }
          }
          if(wood>=(long)B){
              min = mid+1;
              //0 5 10 15
              ans = Math.max(ans,mid);//15
          }else{
              max = mid-1;
          }
      }
      return ans;
    }
}

// C++ program to find the smallest
// window containing all characters
// of a pattern.
#include <bits/stdc++.h>
using namespace std;

const int MAX_CHARS = 256;

// Function to find smallest window containing
// all distinct characters
string findSubString(string str)
{
	int n = str.length();

	// if string is empty or having one char
	if (n <= 1)
		return str;

	// Count all distinct characters.
	int dist_count = 0;
	bool visited[MAX_CHARS] = { false };
	for (int i = 0; i < n; i++) {
		if (visited[str[i]] == false) {
			visited[str[i]] = true;
			dist_count++;
		}
	}

	// Now follow the algorithm discussed in below
	// post. We basically maintain a window of characters
	// that contains all characters of given string.
	int start = 0, start_index = -1, min_len = INT_MAX;

	int count = 0;
	int curr_count[MAX_CHARS] = { 0 };
	for (int j = 0; j < n; j++) {
		// Count occurrence of characters of string
		curr_count[str[j]]++;

		// If any distinct character matched,
		// then increment count
		if (curr_count[str[j]] == 1)
			count++;

		// if all the characters are matched
		if (count == dist_count) {
			// Try to minimize the window i.e., check if
			// any character is occurring more no. of times
			// than its occurrence in pattern, if yes
			// then remove it from starting and also remove
			// the useless characters.
			while (curr_count[str[start]] > 1) {
				if (curr_count[str[start]] > 1)
					curr_count[str[start]]--;
				start++;
			}

			// Update window size
			int len_window = j - start + 1;
			if (min_len > len_window) {
				min_len = len_window;
				start_index = start;
			}
		}
	}

	// Return substring starting from start_index
	// and length min_len
	return str.substr(start_index, min_len);
}


// CPP program for the above approach
#include <bits/stdc++.h>
using namespace std;

// Function to find single occurrence element
int findunique(vector<int>& a, int k)
{
	int res = 0;

	for (int i = 0; i < 32; i++) {
		int p = 0;

		for (int j = 0; j < a.size(); j++) {
			// By shifting 1 to left ith
			// time and taking and with 1
			// will give us that ith
			// bit of a[j] is 1 or 0
			p += (abs(a[j]) & (
				1 << i)) != 0 ? 1 : 0;
		}

		// Taking modulo of p with k
		p %= k;

		// Generate result
		res += pow(2, i) * p;
	}

	int c = 0;

	// Loop for negative numbers
	for (auto x : a)

		if (x == res) {
			c = 1;
			break;
		}

	// Check if the calculated value res
	// is present in array, then mark c=1
	// and if c = 1 return res
	// else res must be -ve
	return c == 1 ? res : -res;
}

// Driver code
int main()
{

	vector<int> a = { 12, 12, 2, 2, 3 };
	int k = 2;

	// Function call
	cout << findunique(a, k) << "\n";
}
// This article is contributed by ajaykr00kj


// C++ program for Kth element in spiral in O(C)C=NO OF CIRCU RING WRTO K.
// form of matrix

/* function for Kth element */
int findK(int A[MAX][MAX], int n, int m, int k)
{
	if (n < 1 || m < 1)
		return -1;

	/*....If element is in outermost ring ....*/
	/* Element is in first row */
	if (k <= m)
		return A[0][k - 1];

	/* Element is in last column */
	if (k <= (m + n - 1))
		return A[(k - m)][m - 1];

	/* Element is in last row */
	if (k <= (m + n - 1 + m - 1))
		return A[n - 1][m - 1 - (k - (m + n - 1))];

	/* Element is in first column */
	if (k <= (m + n - 1 + m - 1 + n - 2))
		return A[n - 1 - (k - (m + n - 1 + m - 1))][0];

	/*....If element is NOT in outermost ring ....*/
	/* Recursion for sub-matrix. &A[1][1] is
	address to next inside sub matrix.*/
	return findK((int(*)[MAX])(&(A[1][1])), n - 2,
				m - 2, k - (2 * n + 2 * m - 4));
}

// C++ program for Kth smallest element in the matrix. in O(N*Log(N))
// form of matrix

int kthSmallest(int mat[MAX][MAX], int n, int k)
{
priority_queue< pair< int, pair< int, int > >, vector < pair < int, pair < int, int >>>, greater< pair < int, pair < int, int >>>> pq;
for (int i = 0; i < n; i++)
pq.push({mat[i][0], {i, 0}});
int c = k, ans;
while (c--) {
int a = pq.top().first;
int b = pq.top().second.first;
int c = pq.top().second.second;
ans = a;
pq.pop();
if (c != n - 1)
pq.push({mat[b][c + 1], {b, c + 1}});
}
return ans;

}

//find median of matrix inplace in (logc*r)
    int median(vector<vector<int>> &matrix, int r, int c)
    {
        int min = INT_MAX, max = INT_MIN;
        for (int i = 0; i < r; i++)
        {
            if (matrix[i][0] < min)
                min = matrix[i][0];
     
            if (matrix[i][c-1] > max)
                max = matrix[i][c-1];
        }
     
        int desired = (r * c + 1) / 2;
        while (min < max)
        {
            int mid = min + (max - min) / 2;
            int place = 0;
            for (int i = 0; i < r; ++i)
                place += upper_bound(matrix[i].begin(), matrix[i].end(), mid) - matrix[i].begin();
            if (place < desired)
                min = mid + 1;
            else
                max = mid;
        }
        return min;
    }


//// Program to find k-th element from two sorted arrays tc:O((log n + log m);
#include <iostream>
using namespace std;

int kth(int *arr1, int *arr2, int *end1, int *end2, int k)
{
	if (arr1 == end1)
		return arr2[k];
	if (arr2 == end2)
		return arr1[k];
	int mid1 = (end1 - arr1) / 2;
	int mid2 = (end2 - arr2) / 2;
	if (mid1 + mid2 < k)
	{
		if (arr1[mid1] > arr2[mid2])
			return kth(arr1, arr2 + mid2 + 1, end1, end2,
				k - mid2 - 1);
		else
			return kth(arr1 + mid1 + 1, arr2, end1, end2,
				k - mid1 - 1);
	}
	else
	{
		if (arr1[mid1] > arr2[mid2])
			return kth(arr1, arr2, arr1 + mid1, end2, k);
		else
			return kth(arr1, arr2, end1, arr2 + mid2, k);
	}
}

int main()
{
	int arr1[5] = {2, 3, 6, 7, 9};
	int arr2[4] = {1, 4, 8, 10};

	int k = 5;
	cout << kth(arr1, arr2, arr1 + 5, arr2 + 4, k - 1);
	return 0;
}

// C++ code for First negative integer
// in every window of size k
#include <iostream>
using namespace std;

void printFirstNegativeInteger(int arr[], int k, int n)
{
	int firstNegativeIndex = 0;
	int firstNegativeElement;
	
	
	for(int i = k - 1; i < n; i++)
	{
	
		// skip out of window and positive elements
		while((firstNegativeIndex < i ) &&
			(firstNegativeIndex <= i - k ||
			arr[firstNegativeIndex] > 0))
		{
			firstNegativeIndex ++;
		}
		
		// check if a negative element is found, otherwise use 0
		if(arr[firstNegativeIndex] < 0)
		{
			firstNegativeElement = arr[firstNegativeIndex];
		}
		else
		{
			firstNegativeElement = 0;
		}
		cout<<firstNegativeElement << " ";
	}
	
}



// A Dequeue (Double ended queue) based
// method for printing maximum element of
// all subarrays of size k

// CPP program for the above approach
#include <bits/stdc++.h>
using namespace std;

 vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        deque<int> dq;
        vector<int> ans;
        for (int i=0; i<nums.size(); i++) {
            if (!dq.empty() && dq.front() == i-k) dq.pop_front();
            
            while (!dq.empty() && nums[dq.back()] < nums[i])
                dq.pop_back();
            
            dq.push_back(i);
            if (i>=k-1) ans.push_back(nums[dq.front()]);
        }
        return ans;
    }


Suppose we have a number A and we want to  
convert it to a number B and there is also a  
constraint that we can recover number A any  
time without using other variable.To achieve  
this we chose a number N which is greater  
than both numbers and add B*N in A.
so A --> A+B*N

To get number B out of (A+B*N)  
we divide (A+B*N) by N (A+B*N)/N = B.

To get number A out of (A+B*N)  
we take modulo with N (A+B*N)%N = A.

-> In short by taking modulo  
we get old number back and taking divide  
we new number.
mergeSort():

Calculate mid two split the array into two halves(left sub-array and right sub-array)
Recursively call merge sort on left sub-array and right sub-array to sort them
Call merge function to merge left sub-array and right sub-array
merge():

// C++ program in-place Merge Sort INPLACE
#include <bits/stdc++.h>
using namespace std;
 
// Merges two subarrays of arr[].
// First subarray is arr[l..m]
// Second subarray is arr[m+1..r]
// Inplace Implementation
void mergeInPlace(int a[], int l, int m, int r)//BASIC MEI O(n^2){SHIFTNG USE HUA THA} LGA ISME O(NLOGN) BS.
{
    // increment the maximum_element by one to avoid
    // collision of 0 and maximum element of array in modulo
    // operation
    int mx = max(a[m], a[r]) + 1;
 
    int i = l, j = m + 1, k = l;
    while (i <= m && j <= r && k <= r) {
 
        // recover back original element to compare
        int e1 = a[i] % mx;
        int e2 = a[j] % mx;
        if (e1 <= e2) {
            a[k] += (e1 * mx);
            i++;
            k++;
        }
        else {
            a[k] += (e2 * mx);
            j++;
            k++;
        }
    }
 
    // process those elements which are left in the array
    while (i <= m) {
        int el = a[i] % mx;
        a[k] += (el * mx);
        i++;
        k++;
    }
 
    while (j <= r) {
        int el = a[j] % mx;
        a[k] += (el * mx);
        j++;
        k++;
    }
 
    // finally update elements by dividing with maximum
    // element
    for (int i = l; i <= r; i++)
        a[i] /= mx;
}
 
/* l is for left index and r is right index of the
   sub-array of arr to be sorted */
void mergeSort(int arr[], int l, int r)
{
    if (l < r) {
 
        // Same as (l + r) / 2, but avoids overflow
        // for large l and r
        int m = l + (r - l) / 2;
 
        // Sort first and second halves
        mergeSort(arr, l, m);
        mergeSort(arr, m + 1, r);
        mergeInPlace(arr, l, m, r);
    }
}
// Iterative C++ program to print sums of all
// possible subsets.
#include <bits/stdc++.h>
using namespace std;

// Prints sums of all subsets of array
void subsetSums(int arr[], int n)
{
	// There are totoal 2^n subsets
	long long total = 1 << n;

	// Consider all numbers from 0 to 2^n - 1
	for (long long i = 0; i < total; i++) {
		long long sum = 0;

		// Consider binary representation of
		// current i to decide which elements
		// to pick.
		for (int j = 0; j < n; j++)
			if (i & (1 << j))
				sum += arr[j];

		// Print sum of picked elements.
		cout << sum << " ";
	}
}

// C++ implementation of above approach
//warna direct print kr do for not changing

void rotate90Clockwise(int arr[N][N])
{
    // printing the matrix on the basis of
    // observations made on indices.
    for (int j = 0; j < N; j++)
    {
        for (int i = N - 1; i >= 0; i--)
            cout << arr[i][j] << " ";
        cout << '\n';
    }
This changes the input matrix
// Function to rotate the matrix 90 degree clockwise
An N x N matrix will have floor(N/2) square cycles. 
For example, a 3 X 3 matrix will have 1 cycle. The cycle is formed by its 1st row, last column,
 last row, and 1st column.For each square cycle, we swap the elements involved with the corresponding cell in the
 matrix in the clockwise direction
void rotate90Clockwise(int a[N][N])
{

	// Traverse each cycle
	for (int i = 0; i < N / 2; i++) {
		for (int j = i; j < N - i - 1; j++) {

			// Swap elements of each cycle
			// in clockwise direction
			int temp = a[i][j];
			a[i][j] = a[N - 1 - j][i];
			a[N - 1 - j][i] = a[N - 1 - i][N - 1 - j];
			a[N - 1 - i][N - 1 - j] = a[j][N - 1 - i];
			a[j][N - 1 - i] = temp;
		}
	}
}




//NO OF SUBARRAY WHOSE PDT<K
int countSubArrayProductLessThanK(const vector<int>& a, int n, long long k) {
        long long p = 1;
        int res = 0;
        for (int start = 0, end = 0; end < n; end++) {
    
            // Move right bound by 1 step. Update the product.
            p *= a[end];
    
            // Move left bound so guarantee that p is again
            // less than k.
            while (start < end && p >= k) p /= a[start++];
    
            // If p is less than k, update the counter.
            // Note that this is working even for (start == end):
            // it means that the previous window cannot grow
            // anymore and a single array element is the only
            // addendum.
            if (p < k) {
                int len = end - start + 1;
                res += len;
            }
        }
    
        return res;
    }
// A C++ program to find a peak element
// using divide and conquer
IN O(LOGN) TIME ITS NOT BS ITS DIV AND CONQ
// A binary search based function
// that returns index of a peak element
int findPeakUtil(int arr[], int low,
				int high, int n)
{
	// Find index of middle element
	// (low + high)/2
	int mid = low + (high - low) / 2;

	// Compare middle element with its
	// neighbours (if neighbours exist)
	if ((mid == 0 || arr[mid - 1] <= arr[mid]) &&
		(mid == n - 1 || arr[mid + 1] <= arr[mid]))
		return mid;

	// If middle element is not peak and its
	// left neighbour is greater than it,
	// then left half must have a peak element
	else if (mid > 0 && arr[mid - 1] > arr[mid])
		return findPeakUtil(arr, low, (mid - 1), n);

	// If middle element is not peak and its
	// right neighbour is greater than it,
	// then right half must have a peak element
	else
		return findPeakUtil(
			arr, (mid + 1), high, n);
}

// C++ program to find Maximum Product Subarray
#include <bits/stdc++.h>
using namespace std;

/* Returns the product
of max product subarray.
Assumes that the given
array always has a subarray
with product more than 1 */
int maxSubarrayProduct(int arr[], int n)
{
	// max positive product
	// ending at the current position
	int max_ending_here = 1;

	// min negative product ending
	// at the current position
	int min_ending_here = 1;

	// Initialize overall max product
	int max_so_far = 0;
	int flag = 0;
	/* Traverse through the array.
	Following values are
	maintained after the i'th iteration:
	max_ending_here is always 1 or
	some positive product ending with arr[i]
	min_ending_here is always 1 or
	some negative product ending with arr[i] */
	for (int i = 0; i < n; i++)
	{
		/* If this element is positive, update
		max_ending_here. Update min_ending_here only if
		min_ending_here is negative */
		if (arr[i] > 0)
		{
			max_ending_here = max_ending_here * arr[i];
			min_ending_here
				= min(min_ending_here * arr[i], 1);
			flag = 1;
		}

		/* If this element is 0, then the maximum product
		cannot end here, make both max_ending_here and
		min_ending_here 0
		Assumption: Output is alway greater than or equal
					to 1. */
		else if (arr[i] == 0) {
			max_ending_here = 1;
			min_ending_here = 1;
		}

		/* If element is negative. This is tricky
		max_ending_here can either be 1 or positive.
		min_ending_here can either be 1 or negative.
		next max_ending_here will always be prev.
		min_ending_here * arr[i] ,next min_ending_here
		will be 1 if prev max_ending_here is 1, otherwise
		next min_ending_here will be prev max_ending_here *
		arr[i] */

		else {
			int temp = max_ending_here;
			max_ending_here
				= max(min_ending_here * arr[i], 1);
			min_ending_here = temp * arr[i];
		}

		// update max_so_far, if needed
		if (max_so_far < max_ending_here)
			max_so_far = max_ending_here;
	}
	if (flag == 0 && max_so_far == 0)
		return 0;
	return max_so_far;
}

Given a binary array arr of size N and an integer M. Find the maximum number of consecutive 1's produced by flipping at most M 0's.
    int findZeroes(int arr[], int n, int m) {
       int res = 0, ct0 = 0;
    
    int i = 0, j = 0;
    
    while(j < n){
        
        if(arr[j] == 0)
            ct0++;
            
        while(ct0 > m){
            if(arr[i] == 0)
                ct0--;
            i++;
        }
        
        res = max(res, j - i + 1);
        j++;
    }
    
    return res;

    }  
 
 int orangesRotting(vector<vector<int>>& grid) {
        if(grid.empty()) return 0;
        int m = grid.size(), n = grid[0].size(), days = 0, tot = 0, cnt = 0;
        queue<pair<int, int>> rotten;
        for(int i = 0; i < m; ++i){
            for(int j = 0; j < n; ++j){
                if(grid[i][j] != 0) tot++;
                if(grid[i][j] == 2) rotten.push({i, j});
            }
        }
        
        int dx[4] = {0, 0, 1, -1};
        int dy[4] = {1, -1, 0, 0};
        
        while(!rotten.empty()){
            int k = rotten.size();
            cnt += k; 
            while(k--){
                int x = rotten.front().first, y = rotten.front().second;
                rotten.pop();
                for(int i = 0; i < 4; ++i){
                    int nx = x + dx[i], ny = y + dy[i];
                    if(nx < 0 || ny < 0 || nx >= m || ny >= n || grid[nx][ny] != 1) continue;
                    grid[nx][ny] = 2;
                    rotten.push({nx, ny});
                }
            }
            if(!rotten.empty()) days++;
        }
        
        return tot == cnt ? days : -}}

 void nextPermutation(vector<int>& n) {
        
    int n = nums.size();
        int i;
        for(i = n - 1 ; i >= 1 ; --i)
        {
            if(nums[i-1] >= nums[i])
                continue;
            break;
        }
        
        if(i == 0){
            reverse(nums.begin() , nums.end());
            return ;
            
        }
        
        i--; //index to be swapped
        
        for(int j = n-1 ; j!= i ; --j)
        {
            if(nums[j] > nums[i])
            {
                swap(nums[j] , nums[i]);
                break;
            }
        }
        reverse(nums.begin()+i+1 , nums.end());
        
    }

//in one pass,warna next and prev smaller se bhi ho jata but in 2 pass.
 int largestRectangleArea(vector<int>& heights) {
        stack<int> st; 
        int maxA = 0; 
        int n = heights.size(); 
        for(int i = 0;i<=n;i++) {
            while(!st.empty() && (i==n || heights[st.top()] >= heights[i])) {
                int height = heights[st.top()];
                st.pop(); 
                int width; 
                if(st.empty()) width = i; 
                else width = i - st.top() - 1; 
                
                // cout << i << " " << width << " " << height << endl; 
                maxA = max(maxA, width * height); 
            }
            st.push(i); 
        }
        return maxA;
    }
